// Problem 1

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we
// get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.

// Problem 2 

// Each new term in the Fibonacci sequence is generated by adding the
// previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not
// exceed four million, find the sum of the even-valued terms.

// Problem 3

// A palindromic number reads the same both ways. The largest palindrome
// made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit
// numbers.

// Problem 4

// 2520 is the smallest number that can be divided by each of the numbers
// from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the
// numbers from 1 to 20?

// Problem 5

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
// that the 6th prime is 13. What is the 10,001st prime number?

// Problem 6 

// Starting in the top left corner of a 2×2 grid, and only being able to move
// to the right and down, there are exactly 6 routes to the bottom right
// corner. How many such routes are there through a 20×20 grid?

// Problem 7

// By starting at the top of the triangle below and moving to adjacent
// numbers on the row below, the maximum total from top to bottom is 23.
// 3
// 7 4
// 2 4 6
// 8 5 9 3
// That is, 3 + 7 + 4 + 9 = 23.
// Find the maximum total from top to bottom in triangle.txt (attached to
// the email), a 15K text file containing a triangle with one-hundred rows.
//Graph search algo

//Answers

//Problem 1

// Function to calculate the sum of an arithmetic progression
const sumArithmeticProgression = (firstTerm, lastTerm, numTerms) =>
    numTerms * (firstTerm + lastTerm) / 2;

// Function to calculate the sum of multiples of n below a limit
const sumMultiplesOf = (n, limit) => {
    // Calculate the count of multiples of n below the limit
    const numMultiples = Math.floor((limit - 1) / n);
    // Calculate the last multiple of n below the limit
    const lastMultiple = numMultiples * n;
    // Calculate the sum of the arithmetic progression of multiples of n
    return sumArithmeticProgression(n, lastMultiple, numMultiples);
};

// Set the limit
const limit = 1000; 

// Calculate the sum of multiples of 3, 5, and 15 below the limit
const sumOfMultiplesOf3 = sumMultiplesOf(3, limit);
const sumOfMultiplesOf5 = sumMultiplesOf(5, limit);
const sumOfMultiplesOf15 = sumMultiplesOf(15, limit);

// Calculate the total sum by adding multiples of 3 and 5 and subtracting multiples of 15
const totalSum = sumOfMultiplesOf3 + sumOfMultiplesOf5 - sumOfMultiplesOf15;

// Display the result
console.log("The sum of all multiples of 3 or 5 below 1000 is:", totalSum);

//Problem 2

// Initialize the previous and current terms of the Fibonacci sequence
let prevTerm = 1;
let currentTerm = 2;

// Initialize the sum of even-valued terms
let sum = 0;

// Continue looping until the current term exceeds four million
while (currentTerm <= 4000000) {
    // Check if the current term is even
    if (currentTerm % 2 === 0) {
        // Add the current even-valued term to the sum
        sum += currentTerm;
    }
    
    // Calculate the next term in the sequence using the adjusted formula
    let nextTerm = prevTerm + 3 * currentTerm;
    
    // Update the previous and current terms for the next iteration
    [prevTerm, currentTerm] = [currentTerm, nextTerm];
}

// Display the result
console.log(`The sum of even-valued Fibonacci terms not exceeding four million is: ${sum}`);


// Problem 3

// Function to check if a number is palindrome
const isPalindrome = num => {
  const numStr = num.toString();
  return numStr === numStr.split('').reverse().join('');
};

// Function to find the largest palindrome product of two 3-digit numbers
const largestPalindromeProduct = () => {
  let largestPalindrome = 0;

  for (let i = 999; i >= 100; i--) {
      // Start j from i to avoid redundant calculations
      // Additionally, we can optimize further by breaking the loop if a larger palindrome is not possible
      for (let j = i; j >= 100 && i * j > largestPalindrome; j--) {
          const product = i * j;

          if (isPalindrome(product)) {
              largestPalindrome = product;
          }
      }
  }

  return largestPalindrome;
};

const result = largestPalindromeProduct();
console.log(`The largest palindrome made from the product of two 3-digit numbers is: ${result}`);


//Problem 4

// Create an object to store the prime factors and their counts
const primeFactors = {};

// Iterate through numbers from 2 to 20
for (let i = 2; i <= 20; i++) {
  let num = i;
  
  // Iterate through potential divisors starting from 2
  for (let j = 2; j <= num; j++) {
    // While num is divisible by j, keep dividing and updating prime factors
    while (num % j === 0) {
      // If the prime factor is not yet in the object, initialize its count
      if (!primeFactors[j]) {
        primeFactors[j] = 0;
      }
      // Increment the count of the prime factor
      primeFactors[j]++;
      num /= j;
    }
  }
}

// Initialize the LCM
let lcm = 1;

// Calculate LCM by multiplying prime factors raised to their respective counts
for (const factor in primeFactors) {
  // Calculate the power using Math.pow and multiply to the LCM
  lcm *= Math.pow(parseInt(factor), primeFactors[factor]);
}

// Print the calculated LCM
console.log(lcm);

// Problem 5

// Function to check if a number is prime
const isPrime = num => {
    if (num <= 1) return false; // 1 is not a prime number
    if (num <= 3) return true;  // 2 and 3 are prime numbers
    if (num % 2 === 0 || num % 3 === 0) return false; // Divisible by 2 or 3
    
    // Check divisibility by numbers of the form 6k +/- 1
    for (let i = 5; i * i <= num; i += 6) {
      if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    
    return true; // If no divisors found, the number is prime
  };
  
  // Function to find the Nth prime number
  const findNthPrime = n => {
    if (n === 1) return 2; // The first prime number is 2
    
    let count = 1; // Starting with the first prime (2)
    let num = 3;   // Starting the search from 3
    
    while (count < n) {
      if (isPrime(num)) count++; // If num is prime, increment the count
      if (count === n) break;    // If desired count is reached, exit loop
      num += 2; // Skip even numbers, as all primes > 2 are odd
    }
    
    return num; // Return the Nth prime number
  };
  
  const nthPrimeToFind = 10001; // Specify the Nth prime number to find
  const nthPrimeResult = findNthPrime(nthPrimeToFind); // Find the Nth prime number
  console.log(`The ${nthPrimeToFind}st prime number is ${nthPrimeResult}.`); // Display the result

  //Problem 6 
  const countRoutes = gridSize => {
    const grid = Array.from({ length: gridSize + 1 }, () => Array(gridSize + 1).fill(0));
  
    // Initialize the boundaries
    grid[0].fill(1);
    grid.forEach(row => (row[0] = 1));
  
    // Calculate routes using dynamic programming
    for (let i = 1; i <= gridSize; i++) {
      for (let j = 1; j <= gridSize; j++) {
        grid[i][j] = grid[i - 1][j] + grid[i][j - 1];
      }
    }
  
    return grid[gridSize][gridSize];
  };
  
  const gridSize = 20;
  const routes = countRoutes(gridSize);
  console.log(`Number of routes through a ${gridSize}x${gridSize} grid: ${routes}`);
  
  import triangleText from "./triangle.txt"


 // Start iterating from the second-to-last row and update the triangle in place
for (let row = triangleText.length - 2; row >= 0; row--) {
  for (let col = 0; col <= row; col++) {
    // Calculate the maximum sum for the current cell by adding the maximum of the two adjacent cells in the next row
    triangle[row][col] += Math.max(triangle[row + 1][col], triangle[row + 1][col + 1]);
  }
}

// The maximum total sum is now stored in the top of the triangle array
const maximumTotal = triangle[0][0];

// Output the final result
console.log("Maximum total:", maximumTotal);
  
  












