// Problem 1

// If we list all the natural numbers below 10 that are multiples of 3 or 5, we
// get 3, 5, 6 and 9. The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.

// Problem 2 

// Each new term in the Fibonacci sequence is generated by adding the
// previous two terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not
// exceed four million, find the sum of the even-valued terms.

// Problem 3

// A palindromic number reads the same both ways. The largest palindrome
// made from the product of two 2-digit numbers is 9009 = 91 × 99.
// Find the largest palindrome made from the product of two 3-digit
// numbers.

// Problem 4

// 2520 is the smallest number that can be divided by each of the numbers
// from 1 to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the
// numbers from 1 to 20?

// Problem 5

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
// that the 6th prime is 13. What is the 10,001st prime number?

// Problem 6 

// Starting in the top left corner of a 2×2 grid, and only being able to move
// to the right and down, there are exactly 6 routes to the bottom right
// corner. How many such routes are there through a 20×20 grid?

// Problem 7

// By starting at the top of the triangle below and moving to adjacent
// numbers on the row below, the maximum total from top to bottom is 23.
// 3
// 7 4
// 2 4 6
// 8 5 9 3
// That is, 3 + 7 + 4 + 9 = 23.
// Find the maximum total from top to bottom in triangle.txt (attached to
// the email), a 15K text file containing a triangle with one-hundred rows.

//Answers

//Problem 1

// Function to calculate the sum of an arithmetic progression
const sumArithmeticProgression = (firstTerm, lastTerm, numTerms) =>
    numTerms * (firstTerm + lastTerm) / 2;

// Function to calculate the sum of multiples of n below a limit
const sumMultiplesOf = (n, limit) => {
    // Calculate the count of multiples of n below the limit
    const numMultiples = Math.floor((limit - 1) / n);
    // Calculate the last multiple of n below the limit
    const lastMultiple = numMultiples * n;
    // Calculate the sum of the arithmetic progression of multiples of n
    return sumArithmeticProgression(n, lastMultiple, numMultiples);
};

// Set the limit
const limit = 1000;

// Calculate the sum of multiples of 3, 5, and 15 below the limit
const sumOfMultiplesOf3 = sumMultiplesOf(3, limit);
const sumOfMultiplesOf5 = sumMultiplesOf(5, limit);
const sumOfMultiplesOf15 = sumMultiplesOf(15, limit);

// Calculate the total sum by adding multiples of 3 and 5 and subtracting multiples of 15
const totalSum = sumOfMultiplesOf3 + sumOfMultiplesOf5 - sumOfMultiplesOf15;

// Display the result
console.log("The sum of all multiples of 3 or 5 below 1000 is:", totalSum);

//Problem 2

// Initialize the previous and current terms in the Fibonacci sequence
let [prevTerm, currentTerm] = [1, 2];
let sum = 0; // Initialize the sum of even-valued terms

// Loop until the current term exceeds four million
while (currentTerm <= 4000000) {
    sum += currentTerm; // Add the current even-valued term to the sum
    
    // Calculate the next even-valued term using the formula
    // The pattern is: odd, odd, even, odd, odd, even, ...
    // So, we add 4 times the current term to get the next even term
    [prevTerm, currentTerm] = [currentTerm, prevTerm + 4 * currentTerm];
}

// Display the result
console.log(`The sum of even-valued Fibonacci terms not exceeding four million is: ${sum}`);

// Problem 3

// Function to check if a number is palindrome
const isPalindrome = num => {
    const numStr = num.toString();
    return numStr === numStr.split('').reverse().join('');
};

// Function to find the largest palindrome product of two 3-digit numbers
const largestPalindromeProduct = () => {
    let largestPalindrome = 0;

    // Using forEach for the outer loop, iterating from 999 down to 100
    Array.from({ length: 900 }, (_, indexI) => 999 - indexI).forEach(i => {
        // Using some for the inner loop, iterating from i down to 100
        // The some function simulates a loop break when returning true
        Array.from({ length: i - 99 }, (_, indexJ) => i - indexJ).some(j => {
            const product = i * j;

            if (product <= largestPalindrome) {
                // Exit the loop if the product is smaller than the current largest palindrome
                return true;
            }

            if (isPalindrome(product)) {
                largestPalindrome = product;
            }

            return false;
        });
    });

    return largestPalindrome;
};

const result = largestPalindromeProduct();
console.log(`The largest palindrome made from the product of two 3-digit numbers is: ${result}`);

//Problem 4

// Create an object to store the prime factors and their counts
const primeFactors = {};

// Iterate through numbers from 2 to 20
for (let i = 2; i <= 20; i++) {
  let num = i;
  
  // Iterate through potential divisors starting from 2
  for (let j = 2; j <= num; j++) {
    // While num is divisible by j, keep dividing and updating prime factors
    while (num % j === 0) {
      // If the prime factor is not yet in the object, initialize its count
      if (!primeFactors[j]) {
        primeFactors[j] = 0;
      }
      // Increment the count of the prime factor
      primeFactors[j]++;
      num /= j;
    }
  }
}

// Initialize the LCM
let lcm = 1;

// Calculate LCM by multiplying prime factors raised to their respective counts
for (const factor in primeFactors) {
  // Calculate the power using Math.pow and multiply to the LCM
  lcm *= Math.pow(parseInt(factor), primeFactors[factor]);
}

// Print the calculated LCM
console.log(lcm);

// Problem 5

// Function to check if a number is prime
const isPrime = num => {
    if (num <= 1) return false; // 1 is not a prime number
    if (num <= 3) return true;  // 2 and 3 are prime numbers
    if (num % 2 === 0 || num % 3 === 0) return false; // Divisible by 2 or 3
    
    // Check divisibility by numbers of the form 6k +/- 1
    for (let i = 5; i * i <= num; i += 6) {
      if (num % i === 0 || num % (i + 2) === 0) return false;
    }
    
    return true; // If no divisors found, the number is prime
  };
  
  // Function to find the Nth prime number
  const findNthPrime = n => {
    if (n === 1) return 2; // The first prime number is 2
    
    let count = 1; // Starting with the first prime (2)
    let num = 3;   // Starting the search from 3
    
    while (count < n) {
      if (isPrime(num)) count++; // If num is prime, increment the count
      if (count === n) break;    // If desired count is reached, exit loop
      num += 2; // Skip even numbers, as all primes > 2 are odd
    }
    
    return num; // Return the Nth prime number
  };
  
  const nthPrimeToFind = 10001; // Specify the Nth prime number to find
  const nthPrimeResult = findNthPrime(nthPrimeToFind); // Find the Nth prime number
  console.log(`The ${nthPrimeToFind}st prime number is ${nthPrimeResult}.`); // Display the result
  












